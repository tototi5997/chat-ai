## 对话逻辑与状态处理

本文档梳理 Chat AI 项目中会话数据的获取与更新流程，涵盖“新建对话”与“进入历史对话”两大场景，帮助在前端实现类似 ChatGPT 的流式渲染体验。

---

### 状态容器方案

- 采用 **Zustand** 作为本地状态管理，集中维护：
  - `sessions`: 会话列表，包含每个会话的 `id`、`title`、`content`、`updatedAt` 等。
  - `currentSessionId`: 当前激活的会话 ID。
  - `pendingMessage`: 当前流式返回的临时消息（尚未写入历史）。
  - 操作方法：如 `createSession`、`appendUserMessage`、`startStreamingAnswer`、`finalizeStream`、`loadHistory` 等。
- React 组件通过 `useStore(selector)` 订阅所需切片，避免不必要的重渲染。
- 若需要持久化，可结合 `zustand/middleware` 的 `persist`，写入 `localStorage` 或 `IndexedDB`。

---

### 一、新建对话流程

1. **初始化状态**

   - 创建新的会话 ID（如 `new_talk_${Date.now()}`）。
   - 调用 `createSession` 并重置 `pendingMessage`，把 `currentSessionId` 指向新会话。
2. **用户输入并发送**

   - 通过 `appendUserMessage` 将用户输入（含附件）写入 Zustand store：
     - 更新 `sessions[currentSessionId].content`，立即渲染历史区块中的用户消息。
     - 如果是全新会话，`createSession` 已将其加入 `sessions` 列表，侧边栏同步可见。
   - 在 UI 中，历史区块立即显示用户消息；进行中区块准备接收 AI 流式回答。
3. **请求流式接口**

   - 触发 `postRequestStreamAPI`（或真实接口），调用 `startStreamingAnswer` 初始化 `pendingMessage`。
   - 逐步消费流式数据，按字符/词追加至 `pendingMessage.content`，store 更新后 UI 以打字机效果渲染。
   - 支持“停止回复”等交互时，中断请求并清理计时器/reader。
4. **流式结束**

   - 调用 `finalizeStream`：把 `pendingMessage` 整体追加到 `sessions[currentSessionId].content`。
   - 清空 `pendingMessage`，更新 `sessions[currentSessionId].updatedAt`，并触发持久化中间件写入本地。

---

### 二、进入历史对话流程

1. **加载历史数据**

   - 调用 `loadHistory(sessionId)`：从 Zustand store（或其持久化副本）获取会话，立即渲染，降低首屏空白。
   - 并行请求后端接口获取最新会话数据，返回后调用 `mergeHistory` 覆盖或补齐 store 中的数据。
2. **同步本地状态**

   - 更新 `currentSessionId`，清空 `pendingMessage`，确保界面只展示历史内容。
   - 若服务器返回的记录与本地有差异，按时间戳或版本号进行合并，避免重复。
3. **用户继续提问**

   - 调用 `appendUserMessage` 向当前会话写入新的用户消息。
   - 与新建对话流程相同，启动流式请求并使用 `pendingMessage` 渲染正在生成的答案。
4. **流式结束**

   - 通过 `finalizeStream` 将生成的 AI 消息落盘至会话内容。
   - 在会话列表中同步最新摘要（如最后一句内容、更新时间），确保侧边栏及时更新。

---

### 三、状态管理要点

- **历史区块 vs 进行中区块**：历史区块只展示 `sessions[currentSessionId].content` 中已完成的消息；进行中区块负责 `pendingMessage` 的流式渲染，完成后再写入历史区块。
- **缓存策略**：Zustand store 作为单一事实来源，可配合 `persist` 中间件持久化；若已有 React Query，可保留用于服务端同步，避免重复存储逻辑。
- **错误处理**：流式中断、网络错误时需重置 `pendingMessage`，提示用户并允许重试。
- **同步机制**：在流式结束或历史数据返回后，统一更新本地缓存和 UI，保持历史列表与对话内容一致。

通过以上流程，可以在用户新建对话与切换历史对话时，保持数据管理清晰、渲染顺畅，实现接近 ChatGPT 的交互体验。
